---
title: "Utilizing Angular's provideAppInitializer to load a module federation remote during application initialization"
publishedOn: '2026-01-22'
author: Laurence Ininda
summary: "Alternative title: intercepting Angular's bootstraping (starting up process) to running an async process"
slug: 'utilizing-angulars-provideappinitializer-with-module-federation-remotes'
tags: ['angular', 'tutorials', 'module federation']
type: dev
image: ''
imageDescription: ''
imageCredit: Photo by <a href="https://unsplash.com/@miyatankun?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Takashi Miyazaki</a> on <a href="https://unsplash.com/photos/two-pink-and-white-flowers-on-a-black-background-iPpJmIjypGg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
imageOriginalUrl: 'https://unsplash.com/photos/two-pink-and-white-flowers-on-a-black-background-iPpJmIjypGg'
---

import { Callout } from 'vocs/components'

# Utilizing Angular's `provideAppInitializer` to load a module federation remote during application initialization

![Cover Image](/assets/post-covers/utilizing-angulars-provideappinitializer-with-module-federation-remotes.jpg)

## TLDR:
In a micro-frontend setup with Angular and module federation, we can intercept Angular's bootstraping process to execute code from a remote application before the host application fully initializes using [`provideAppInitializer`](https://angular.dev/api/core/provideAppInitializer).

## Problem Context 
Our team works on a micro-frontend Angular application that sits across multiple environments that includes testing, staging and production environments.
These environments all have different environment variables such as api endpoints, cdn urls, e.t.c. 

<Callout type="info">
No secrets are stored in these environment files because they are all shipped to the client side.
</Callout>

We utilize NX for our micro-frontend setup which makes the setup easier to manage. The NX docs provides [very good documentation on getting started with NX, Angular and Module Federation.](https://nx.dev/docs/technologies/angular/guides/dynamic-module-federation-with-angular)

During a deployment of our microfrontend to each of the environments, the pipeline swaps out the values in the compiled `environment.ts` file with the appropriate values for each of these environments.
The microfrontend (in our case called `remote-app`) [exposes](https://module-federation.io/configure/exposes.html) two remotes in the `module-federation.config.ts` file: 

1. `remoteRoutes` - routes that configure the child routing logic
2. `environment` - the environment file that contains environment variables

<Callout type="tip">
Think of a remote as a javascript file that contains a piece of code to be "fetched" by another application. 
</Callout>


```ts twoslash
import {ModuleFederationConfig} from '@nx/module-federation';
// ---cut---
const moduleFederationConfig: ModuleFederationConfig = {
  name: 'remote-app',
  exposes: {
    './remoteRoutes': 'apps/remote-app/src/app/routes.ts',
    './environment': 'apps/remote-app/src/environments/environment.ts',
  },
};
```

These remotes can then be fetched from the host application by using the `loadRemote` module federation function from `@module-federation/enhanced/runtime`. i.e.:

```ts twoslash

// [!include ~/snippets/2026/initializing-env-variables-in-ng-mf.ts] 
// bootstrap.ts in the host application
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { loadRemote } from '@module-federation/enhanced/runtime';

// ---cut---
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter([
      { path: '', component: HomeComponent },
// @noErrors
      /* This loads the remote routes to the applications router such that going to /remoteUrl loads the routes from the microfrontend */
      { path: 'remoteUrl', loadChildren: () => loadRemote('remote-app/remoteRoutes').then(m => m.remoteRoutes)} // [!code focus] 
    ]),
    // other providers...
  ]
})
```

The set up would look like this figuratively:

<img
    alt="Host and remote applications in module federation"
    src={'/assets/images/host+remote.png'}
    width={'100%'}
/>

This environment file contains mostly environment variables specific to each environment. 
These values need to be available at run time.

An example of an environment file would be: 

```ts twoslash
export const environment = {
  apiUrl: 'https://api-dev.our-app.com/v1.0/',
  cdnUrl: 'https://cdn-dev.our-app.com/',
  appInsightsUrl: 'https://app-insights-dev.our-app.com/',
} as const
```

<Callout type="info">
This environment file for our microfrontend is hosted on the remote url and so the host application does not know the values at the point of initialization. 
The challenge then was how to load this environment file and make it available to the host application when the application starts up (at initialization).
</Callout>

## Utilizing `provideAppInitializer`
Angular provides a way to run async during the boostraping phase through the `provideAppInitializer` that is [provided at the application startup phase](https://angular.dev/api/core/provideAppInitializer). 
If an async process is to be run, we can pass this function to be executed in the bootstrap phase and angular will not complete initialization until this async logic completes - an observable completes or a promise resolve.

We would first need to modify how we pass in our environment variables and load them into a service. As well, we would need to define a function to run in the `provideAppInitializer` callback. For our example, we will name our function `initialize()` (but you can choose to call your function something different such as `init` or `setup`):

```ts twoslash
// [!include ~/snippets/2026/app-env-service.ts:appenvservice]
```

Notice here that our environment service contains a function that returns a promise. 
This is the function that we would pass into the `provideAppInitializer` function:

--- 

In the `bootstrap.ts` file for our host application, we can then initialize our `AppEnvService` to set up environment variables:

```ts twoslash
// [!include ~/snippets/2026/initializing-env-variables-in-ng-mf.ts] 
// [!include ~/snippets/2026/app-env-service.ts]
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { loadRemote } from '@module-federation/enhanced/runtime';
import { provideAppInitializer } from '@angular/core'
// ---cut---
bootstrapApplication(AppComponent, {
  providers: [
    // Inject the AppEnvironment and call the initialize function
    provideAppInitializer(() => inject(AppEnvService).initialize()), // [!code focus] 
    provideRouter([
      { path: '', component: HomeComponent },
// @noErrors
      { path: 'remoteUrl', loadChildren: () => loadRemote('remote-app/remoteRoutes').then(m => m.routes)}
    ]),
    // other providers...
  ]
})

```

During the application startup phase, Angular will run this async `AppEnvService.initialize()` function, fetch our environment variables and populate them into our `AppEnvService`.

## Epilogue
The main reason for implementing module federation was because two teams working on various parts of the application wanted to deploy independently. 
This is not what micro-frontends were designed for as our micro-frontend does not operate independently. 

I do wonder what the [`loadRemote`](https://module-federation.io/guide/basic/runtime/runtime-api#runtime-api) function does specifically under the hood to fetch and load the remote routes, and provides the same angular context as the host application.
Something to investigate further!